#!/bin/sh
set -e

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BASE_DIR="$HOME/Videos/screencasts"
DEFAULT_FPS="60"

mkdir -p "$BASE_DIR"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DEPENDENCY CHECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for cmd in wf-recorder wlr-randr ffmpeg fzf pactl awk sed grep sort; do
  command -v "$cmd" >/dev/null 2>&1 || {
    echo "âŒ Missing dependency: $cmd"
    exit 1
  }
done

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DETECT MAX MONITOR REFRESH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MAX_REFRESH=$(wlr-randr 2>/dev/null \
  | awk '
      {
        for (i=1; i<=NF; i++) {
          if ($i == "Hz") {
            print $(i-1)
          } else if ($i ~ /Hz$/) {
            gsub(/Hz$/, "", $i)
            print $i
          }
        }
      }
    ' \
  | sort -nr \
  | head -n1)

MAX_REFRESH=${MAX_REFRESH:-60}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ OUTPUT FILE NAME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TIMESTAMP="$(date +%Y%m%d_%H%M%S)"

DEFAULT_NAME="screencast_${TIMESTAMP}"

OUT_NAME=$(printf "%s\n" "$DEFAULT_NAME" \
    | fzf --prompt="filename> " --print-query \
    | awk 'NR==1 && $0!="" {print; exit} NR==2 {print; exit}')

[ -z "$OUT_NAME" ] && exit 1

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONTAINER FORMAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CONTAINER=$(printf "mkv\nmp4\nwebm\nmov" \
  | fzf --prompt="container> ") || exit 1

OUT_FILE="$BASE_DIR/${OUT_NAME}.${CONTAINER}"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ VIDEO ENCODERS (CURATED, DYNAMIC) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
VIDEO_CODECS=$(ffmpeg -encoders 2>/dev/null \
  | awk '/^[[:space:]]*V/ {print $2}' \
  | grep -E '
      ^(h264|hevc|av1)_(nvenc|vaapi|qsv|amf)$|
      ^libx264$|
      ^libx265$|
      ^libsvtav1$|
      ^librav1e$|
      ^libaom-av1$|
      ^ffv1$|
      ^huffyuv$
    ' \
  | sort -u)

[ -z "$VIDEO_CODECS" ] && {
  echo "âŒ No suitable video encoders found"
  exit 1
}

VIDEO_CODEC=$(printf "%s\n" $VIDEO_CODECS \
  | awk '
      {
        label=$0
        if ($0 ~ /nvenc/) label="NVIDIA NVENC (" $0 ")"
        else if ($0 ~ /vaapi/) label="VAAPI (" $0 ")"
        else if ($0 ~ /qsv/) label="Intel QSV (" $0 ")"
        else if ($0 ~ /amf/) label="AMD AMF (" $0 ")"
        else if ($0 == "libx264") label="x264 (software)"
        else if ($0 == "libx265") label="x265 (software)"
        else if ($0 ~ /av1/) label="AV1 (" $0 ")"
        else if ($0 == "ffv1") label="FFV1 (lossless)"
        else if ($0 == "huffyuv") label="HuffYUV (lossless)"
        print label " ::: " $0
      }
    ' \
  | fzf --prompt="encoder> " \
  | sed 's/.* ::: //') || exit 1

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ AUDIO SOURCE (FRIENDLY NAMES) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AUDIO_SOURCE=$(pactl list sources \
  | awk '
      /^Source #/ {name=""; desc=""}
      /^\s*Name:/ {name=$2}
      /^\s*Description:/ {
        desc=$2
        for (i=3;i<=NF;i++) desc=desc" "$i
        print desc " ::: " name
      }
    ' \
  | fzf --prompt="audio> " \
  | sed 's/.* ::: //') || exit 1

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FRAMERATE (CAPPED TO MONITOR) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FPS_CANDIDATES="24
30
60
90
120
144
165
240"

FPS_OPTIONS=$(printf "%s\n" $FPS_CANDIDATES \
  | awk -v max="$MAX_REFRESH" '($1+0) <= (max+0)')

FPS=$(printf "%s\n" "$FPS_OPTIONS" \
  | fzf --prompt="fps (â‰¤ ${MAX_REFRESH}Hz)> ")

FPS="${FPS:-$DEFAULT_FPS}"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ENCODER TUNING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ENCODER_OPTS=""

case "$VIDEO_CODEC" in
  # â”€â”€â”€â”€â”€ NVIDIA NVENC â”€â”€â”€â”€â”€
  h264_nvenc|hevc_nvenc|av1_nvenc)
    # NVENC supports qp or cq; qp is predictable for capture
    ENCODER_OPTS="-p qp=18"
    ;;

  # â”€â”€â”€â”€â”€ AMD AMF â”€â”€â”€â”€â”€
  h264_amf|hevc_amf|av1_amf)
    # AMF uses qp-based quality
    ENCODER_OPTS="-p qp=18"
    ;;

  # â”€â”€â”€â”€â”€ Intel Quick Sync â”€â”€â”€â”€â”€
  h264_qsv|hevc_qsv|av1_qsv)
    # QSV uses global_quality
    ENCODER_OPTS="-p global_quality=20"
    ;;

  # â”€â”€â”€â”€â”€ VAAPI â”€â”€â”€â”€â”€
  h264_vaapi|hevc_vaapi|av1_vaapi)
    # VAAPI generally uses qp
    ENCODER_OPTS="-p qp=18"
    ;;

  # â”€â”€â”€â”€â”€ Software H.264 / H.265 â”€â”€â”€â”€â”€
  libx264)
    # ENCODER_OPTS="-p crf=18 -p preset=medium"
    ENCODER_OPTS="-p qp=18"
    ;;
  libx265)
    # ENCODER_OPTS="-p crf=18 -p preset=medium"
    ENCODER_OPTS="-p qp=18"
    ;;

  # â”€â”€â”€â”€â”€ Software AV1 â”€â”€â”€â”€â”€
  libsvtav1)
    ENCODER_OPTS="-p crf=30"
    ;;
  librav1e)
    ENCODER_OPTS="-p quantizer=80"
    ;;
  libaom-av1)
    ENCODER_OPTS="-p cq=30"
    ;;

  # â”€â”€â”€â”€â”€ Lossless / Archival â”€â”€â”€â”€â”€
  ffv1)
    ENCODER_OPTS="-p level=3"
    ;;
  huffyuv)
    ENCODER_OPTS=""
    ;;

  # â”€â”€â”€â”€â”€ Unknown encoder â”€â”€â”€â”€â”€
  *)
    ENCODER_OPTS=""
    echo "âš ï¸ Unsupported or unknown encoder: $VIDEO_CODEC"
    echo "Using defaults."
    ;;
esac

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PIXEL FORMAT (FIXED PER ENCODER FAMILY) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
case "$VIDEO_CODEC" in

  # NVIDIA NVENC hardware encoders
  *_nvenc)
    # NVENC generally supports yuv420p / nv12 / p010le, choose nv12 for max compatibility
    PIX_FMT="-x gbrp"
    ;;

  # Intel Quick Sync
  *_qsv)
    # QSV tends to support nv12/p010le; choose nv12
    PIX_FMT="-x nv12"
    ;;

  # AMD AMF encoders
  *_amf)
    # AMF supports nv12/yuv420p/p010le; choose nv12
    PIX_FMT="-x nv12"
    ;;

  # VAAPI hardware acceleration
  *_vaapi)
    PIX_FMT="-x vaapi"
    ;;

  # Software x264/x265
  libx264|libx265)
    # These support a wider set of formats; use gbrp for chroma fidelity
    # PIX_FMT="-x yuv422p10le"
    PIX_FMT="-x yuv444p10le"
    ;;

  # AV1 software variants
  libsvtav1|librav1e|libaom-av1)
    # AV1 supports multiple; fallback to nv12 for compatibility
    PIX_FMT="-x nv12"
    ;;

  # Lossless/archival
  ffv1|huffyuv)
    # YUV420p is safe for lossless formats
    PIX_FMT="-x yuv420p"
    ;;

  *)
    # Fallback: let ffmpeg choose
    PIX_FMT=""
    ;;
esac

if [ -n "$PIX_FMT" ]; then
  PIX_FMT_OPTS="$PIX_FMT"
else
  PIX_FMT_OPTS=""
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SUMMARY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
clear
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
echo "ğŸ¥ wf-recorder configuration"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
echo " Monitor Hz : $MAX_REFRESH"
echo " Encoder    : $VIDEO_CODEC"
echo " Enc Opts   : $ENCODER_OPTS"
echo " Pixel Fmt  : $PIX_FMT_OPTS"
echo " FPS        : $FPS"
echo " Audio      : $AUDIO_SOURCE"
echo " Output     : $OUT_FILE"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
echo "â–¶ Recordingâ€¦  Press Ctrl+C to stop"
echo

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ RECORD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
wf-recorder \
  -c "$VIDEO_CODEC" \
  -C aac \
  --audio="$AUDIO_SOURCE" \
  -r "$FPS" \
  -f "$OUT_FILE" \
  $ENCODER_OPTS \
  -p color_range=full \
  $PIX_FMT_OPTS

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SUCCESS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
echo
echo "âœ… Recording completed successfully!"
echo "ğŸ“ Saved to:"
echo "   $OUT_FILE"

